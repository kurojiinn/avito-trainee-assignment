# Руководство по комментариям в коде

Этот документ объясняет систему комментариев, используемую в проекте.

## Типы комментариев

### 1. Package комментарии

Каждый пакет должен иметь комментарий, объясняющий его назначение:

```go
// Package repository предоставляет функции для работы с базой данных.
// Репозитории отвечают за выполнение SQL запросов и преобразование
// данных БД в доменные модели.
package repository
```

### 2. Экспортируемые функции и типы

Все экспортируемые функции и типы должны иметь комментарии:

```go
// UserRepository предоставляет методы для работы с пользователями в БД.
// Использует стандартный database/sql для выполнения запросов.
type UserRepository struct {
    DB *sql.DB
}

// CreateUser сохраняет нового пользователя в базе данных.
//
// Параметры:
//   - user: объект пользователя с заполненными полями (ID генерируется автоматически)
//
// Возвращает:
//   - error: ошибка, если не удалось сохранить (например, дубликат username)
//
// Пример:
//   user := &model.User{
//       Username: "john",
//       TeamID: teamID,
//       IsActive: true,
//   }
//   err := repo.CreateUser(user)
func (r *UserRepository) CreateUser(user *model.User) error {
    // ...
}
```

### 3. Внутренние комментарии

Сложная логика должна быть прокомментирована:

```go
// Получаем активных пользователей команды, исключая автора PR
// Это необходимо, чтобы автор не мог быть ревьювером своего PR
candidates, err := s.userRepo.GetActiveUsersByTeam(author.TeamID, pr.AuthorID)
```

### 4. Бизнес-правила

Важные бизнес-правила должны быть задокументированы:

```go
// ВАЖНО: После объединения PR (статус MERGED) нельзя изменять список ревьюверов.
// Это бизнес-правило, которое обеспечивает целостность данных.
if pr.Status == model.MERGED {
    return nil, errors.New("cannot reassign reviewers for merged PR")
}
```

## Стиль комментариев

### Используйте полные предложения

❌ Плохо:
```go
// создает пользователя
func CreateUser(...)
```

✅ Хорошо:
```go
// CreateUser создает нового пользователя в базе данных.
func CreateUser(...)
```

### Объясняйте "почему", а не "что"

❌ Плохо:
```go
// Проверяем статус
if pr.Status == model.MERGED {
```

✅ Хорошо:
```go
// Проверяем статус PR, так как нельзя переназначать ревьюверов
// в уже объединенном PR (бизнес-правило)
if pr.Status == model.MERGED {
```

### Комментируйте сложную логику

```go
// Оптимизированный запрос: проверяем статус и существование ревьювера
// в одном запросе для уменьшения количества обращений к БД
// Это важно для производительности при больших объемах данных
var status string
var reviewerExists bool
checkQuery := `
    SELECT pr.status, EXISTS(
        SELECT 1 FROM pr_reviewers 
        WHERE pr_id = $1 AND reviewer_id = $2
    )
    FROM pull_requests pr
    WHERE pr.id = $1
`
```

## Примеры хороших комментариев

### Пример 1: Репозиторий

```go
// GetActiveUsersByTeam возвращает список активных пользователей команды,
// исключая указанного пользователя.
//
// Используется при назначении ревьюверов на PR, чтобы исключить автора
// из списка кандидатов.
//
// Параметры:
//   - teamID: идентификатор команды
//   - excludeID: идентификатор пользователя, которого нужно исключить
//
// Возвращает:
//   - []model.User: список активных пользователей (is_active = true)
//   - error: ошибка выполнения запроса
//
// Пример:
//   // Получить всех активных пользователей команды, кроме автора PR
//   candidates, err := repo.GetActiveUsersByTeam(teamID, authorID)
func (r *UserRepository) GetActiveUsersByTeam(teamID uuid.UUID, excludeID uuid.UUID) ([]model.User, error) {
    // ...
}
```

### Пример 2: Сервис

```go
// CreatePR создает новый Pull Request и автоматически назначает ревьюверов.
//
// Бизнес-логика:
//   1. Проверяется существование автора
//   2. Получаются активные пользователи команды автора
//   3. Автор исключается из списка кандидатов
//   4. Случайным образом выбираются до 2 ревьюверов
//   5. Если кандидатов меньше 2, назначается доступное количество (0/1)
//
// Параметры:
//   - pr: объект PR с заполненными Title и AuthorID
//
// Возвращает:
//   - *model.PullRequest: созданный PR с назначенными ревьюверами
//   - error: ошибка, если автор не найден или не удалось создать PR
//
// Пример:
//   pr := &model.PullRequest{
//       Title: "Add new feature",
//       AuthorID: authorID,
//   }
//   createdPR, err := service.CreatePR(pr)
func (s *PRService) CreatePR(pr *model.PullRequest) (*model.PullRequest, error) {
    // ...
}
```

### Пример 3: Хэндлер

```go
// ReassignReviewer переназначает одного ревьювера на другого.
//
// HTTP метод: POST
// Endpoint: /api/v1/pull-requests/{pull_request_id}/reassign
//
// Request body:
//   {
//     "reviewer_id": "uuid-старого-ревьювера"
//   }
//
// Бизнес-правила:
//   - PR должен иметь статус OPEN (нельзя переназначать в MERGED)
//   - Старый ревьювер должен быть назначен на PR
//   - Новый ревьювер выбирается из команды старого ревьювера
//
// HTTP коды ответа:
//   - 200: успешное переназначение
//   - 400: неверный запрос (невалидный UUID, PR мержен, ревьювер не назначен)
//   - 404: PR не найден
//   - 500: внутренняя ошибка
func (h *PRHandler) ReassignReviewer(w http.ResponseWriter, r *http.Request) {
    // ...
}
```

## Что НЕ комментировать

### Очевидные вещи

❌ Плохо:
```go
// Увеличиваем счетчик на 1
counter++
```

✅ Хорошо (без комментария):
```go
counter++
```

### Имена переменных

❌ Плохо:
```go
// ID пользователя
userID := ...
```

✅ Хорошо (без комментария, если имя понятное):
```go
userID := ...
```

## Резюме

1. **Package комментарии** - обязательны для всех пакетов
2. **Экспортируемые функции** - обязательны, с описанием параметров и возвращаемых значений
3. **Сложная логика** - должна быть прокомментирована
4. **Бизнес-правила** - должны быть задокументированы
5. **Очевидные вещи** - не комментировать

